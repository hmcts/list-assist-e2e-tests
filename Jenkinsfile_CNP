}
#!groovy

properties([
  disableConcurrentBuilds(),
  parameters([
    string(
      name: 'FUNCTIONAL_TESTS_WORKERS',
      defaultValue: '4',
      description: 'Number of workers running functional tests'
    ),
    string(
      name: 'TAGS_TO_RUN',
      defaultValue: '',
      description: 'Optionally, run a single or multiple tags (comma separated e.g. @cui, @exui)'
    ),
    choice(
      name: 'browser',
      choices: ['chrome', 'firefox', 'webkit', 'edge'],
      description: 'Which browser to use'
    ),
    choice(
      name: 'TEST_SUITE',
      choices: ['bvt', 'regression', 'bvt_and_regression'],
      description: 'Select which test suite(s) to run',
      defaultValue: 'bvt'
    ),
    choice(
      name: 'ENVIRONMENT',
      choices: ['TRG', 'SIT'],
      description: 'Which environment to run tests against',
      defaultValue: 'TRG'
    ),
  ])
])

@Library("Infrastructure")

def type = "nodejs"
def product = "snl-automation"
def component = "e2e-tests"
def channel = "#list-assist-qa-builds"

static Map<String, Object> secret(String secretName, String envVariable) {
  [
    $class: 'AzureKeyVaultSecret',
    secretType: 'Secret',
    name: secretName,
    envVariable: envVariable
  ]

def secrets = [
  'snl-automation-bts-stg': [
    // TRG secrets
    secret('test-password', 'TEST_USERNAME'),
    secret('test-username', 'TEST_PASSWORD'),
    secret('trg-base-url', 'TRG_BASE_URL'),
    secret('hmi-client-id', 'HMI_CLIENT_ID'),
    secret('hmi-client-secret', 'HMI_CLIENT_SECRET'),
    secret('hmi-scope', 'HMI_SCOPE'),
    secret('hmi-token-url', 'HMI_TOKEN_URL'),
    secret('hmi-token-tenant', 'HMI_TOKEN_TENANT'),
    secret('hmi-grant-type', 'HMI_GRANT_TYPE'),
    secret('hmi-trg-api-url', 'HMI_TRG_API_URL'),

    // SIT secrets
    secret('sit-base-url', 'SIT_BASE_URL'),
    secret('hmi-sit-api-url', 'SIT_HMI_API_URL'),
  ]
]

def buildPlaywrightCommand(tags) {
  if (tags == null || tags.trim().isEmpty()) {
    return;
  }
  def tagList = tags.split(',').collect { it.trim() }
  def command = 'playwright test'
  tagList.each { tag ->
    if (!tag.isEmpty()) {
      command += " --grep ${tag} --project ${params.browser}"
    }
  }
  return command

withNightlyPipeline(type, product, component, 600) {
  loadVaultSecrets(secrets)
  env.CITIZEN_FRONTEND_BASE_URL = params.CITIZEN_FRONTEND_BASE_URL
  env.MANAGE_CASES_BASE_URL = params.MANAGE_CASES_BASE_URL
  env.FUNCTIONAL_TESTS_WORKERS = params.FUNCTIONAL_TESTS_WORKERS
  enableSlackNotifications(channel)

  def yarnBuilder = new uk.gov.hmcts.contino.YarnBuilder(this)

  def browsers = ['chrome', 'firefox']
  def testConfigs = [
    [name: 'Add Participant Tests', grep: '@add-participant'],
    [name: 'Case Creation Tests', grep: '@add-new-case'],
    [name: 'Case Listing and Reporting Tests', grep: '@case-listing-and-reporting'],
    [name: 'Hearing Channel Tests', grep: '@hearing-channel'],
    [name: 'UI Tests', grep: '@ui-test'],
    [name: 'Add new user test', grep: '@add-user', skip: 'true'],
    [name: 'Daily cause reports test', grep: '@daily-cause-list-tests'],

    // Only run Amend Api Tests before listing in Chrome
    [name: 'Amend Api Tests before listing', grep: '@amend-api-test', skipCreateCase: 'true', browsers: ['chrome']],
    // Only run Amend Api test after listing in Chrome
    [name: 'Amend Api test after listing', grep: '@amend-api-test-after-listing', skipCreateCase: 'true', browsers: ['chrome']]
  ]

  def bvtStages = browsers.collectMany { browser ->
    testConfigs.findAll { !it.browsers || it.browsers.contains(browser) }.collect { cfg ->
      [
        name: "${browser.capitalize()} - ${cfg.name}",
        command: "playwright test --project=${browser} --grep ${cfg.grep}",
        skipCreateCase: cfg.skipCreateCase
      ]
    }
  } + [
    [name: 'Webkit - Smoke Tests', command: 'playwright test --project=webkit --grep @smoke']
  ]

  def regressionBrowsers = ['chrome']
  def regressionConfigs = [
    [name: 'Data Reporting Test', grep: '@data-reporting', path: 'regression']
  ]

  def regressionStages = regressionBrowsers.collectMany { browser ->
    regressionConfigs.collect { cfg ->
      [
        name: "${browser.capitalize()} - ${cfg.name}",
        command: "playwright test ${cfg.path} --project=${browser} --grep ${cfg.grep}"
      ]
    }
  }

  def runPlaywrightStage = { stageName, command, reportName, skipCreateCase = null ->
    stage(stageName) {
      try {
        if (skipCreateCase != null) {
          env.SKIP_CREATE_CASE = skipCreateCase
        }
        yarnBuilder.yarn(command)
      } catch (Error) {
        unstable(message: "${STAGE_NAME} is unstable: " + Error.toString())
      } finally {
        publishHTML([
          allowMissing: true,
          alwaysLinkToLastBuild: true,
          keepAll: true,
          reportDir: "playwright-report",
          reportFiles: 'index.html',
          reportName: reportName
        ])
        if (skipCreateCase != null) {
          env.SKIP_CREATE_CASE = null
        }
      }
    }
  }

  def runBvtStages = { stages ->
    stages.each { s ->
      runPlaywrightStage(s.name, s.command, s.name, s.skipCreateCase ?: null)
    }
  }

  def runRegressionStages = { stages ->
    stages.each { s ->
      if (s.skip != 'true') {
        runPlaywrightStage(s.name, s.command, s.name)
      } else {
        echo "Skipping stage: ${s.name} because skip is set to true"
      }
    }
  }

  afterAlways('DependencyCheckNightly') {
  def regressionBlockChanged = false
  def bvtFilesChanged = []
  def isPrBuild = env.CHANGE_ID ? true : false
  def prBuildTaggedFiles = []
  def bvtSpecFilesChanged = []
  def regressionSpecFilesChanged = []

  stage('Prepare Test Run') {
    if (isPrBuild) {
      // Detect Regression & BVT Folder Change
      sh 'git remote set-url origin $(git config --get remote.origin.url)'
      sh 'git fetch --prune --unshallow || git fetch --all'
      sh 'git fetch origin +refs/heads/*:refs/remotes/origin/*'
      sh "git fetch origin '${env.CHANGE_BRANCH}':'${env.CHANGE_BRANCH}'"
      sh "git fetch origin '${env.CHANGE_TARGET}':'${env.CHANGE_TARGET}'"

      def diffRegressionCmd = "git diff --name-only origin/'${env.CHANGE_TARGET}'...origin/'${env.CHANGE_BRANCH}' | grep -q 'regression/'";
      regressionBlockChanged = (sh(script: diffRegressionCmd, returnStatus: true) == 0)

      def diffBvtCmd = "git diff --name-only origin/'${env.CHANGE_TARGET}'...origin/'${env.CHANGE_BRANCH}' | grep '^bvt/' || true"
      def bvtDiffOutput = sh(script: diffBvtCmd, returnStdout: true).trim()
      if (bvtDiffOutput) {
        bvtFilesChanged = bvtDiffOutput.split('\\n')
      }

      // Find changed spec.ts files in bvt and regression folders
      def diffBvtSpecCmd = "git diff --name-only origin/${env.CHANGE_TARGET}...origin/${env.CHANGE_BRANCH} | grep 'bvt/.*\\.spec\\.ts\$' || true"
      def bvtSpecDiffOutput = sh(script: diffBvtSpecCmd, returnStdout: true).trim()
      if (bvtSpecDiffOutput) {
        bvtSpecFilesChanged = bvtSpecDiffOutput.split('\n')
        echo "Detected changed bvt spec files: ${bvtSpecFilesChanged}"
      } else {
        echo "No changed bvt spec files detected."
      }

      def diffRegressionSpecCmd = "git diff --name-only origin/${env.CHANGE_TARGET}...origin/${env.CHANGE_BRANCH} | grep 'regression/.*\\.spec\\.ts\$' || true"
      def regressionSpecDiffOutput = sh(script: diffRegressionSpecCmd, returnStdout: true).trim()
      if (regressionSpecDiffOutput) {
        regressionSpecFilesChanged = regressionSpecDiffOutput.split('\n')
        echo "Detected changed regression spec files: ${regressionSpecFilesChanged}"
      } else {
        echo "No changed regression spec files detected."
      }

      // Find @pr-build tagged files
      def prBuildFilesOutput = sh(
        script: "grep -rl '@pr-build' bvt/ regression/ || true",
        returnStdout: true
      ).trim()
      if (prBuildFilesOutput) {
        prBuildTaggedFiles = prBuildFilesOutput.split('\n')
      }

      // Remove pr-build tagged files from changed files lists
      bvtSpecFilesChanged = bvtSpecFilesChanged.findAll { !prBuildTaggedFiles.contains(it) }
      regressionSpecFilesChanged = regressionSpecFilesChanged.findAll { !prBuildTaggedFiles.contains(it) }
    }

    // Set up playwright
    def skipGlobalSetup = false
    if (params.TAGS_TO_RUN) {
      def tags = params.TAGS_TO_RUN.split(',').collect { it.trim() }
      if (tags.every { it == '@amend-api-test' || it == '@amend-api-test-after-listing' }) {
        skipGlobalSetup = true
      }
    }

    if (!skipGlobalSetup) {
      try {
        yarnBuilder.yarn('setup')
      } catch (Error) {
        unstable(message: "${STAGE_NAME} is unstable: " + Error.toString())
      }
    } else {
      echo "Skipping global setup for amend-api test tags"
    }

    // Before running tests, set environment variables based on ENVIRONMENT
    if (params.ENVIRONMENT == 'SIT') {
      env.TEST_USERNAME = env.EST_USERNAME
      env.TEST_PASSWORD = env.TEST_PASSWORD
      env.TRG_BASE_URL = env.SIT_BASE_URL
      env.HMI_CLIENT_ID = env.HMI_CLIENT_ID
      env.HMI_CLIENT_SECRET = env.HMI_CLIENT_SECRET
      env.HMI_SCOPE = env.HMI_SCOPE
      env.HMI_TOKEN_URL = env.HMI_TOKEN_URL
      env.HMI_TOKEN_TENANT = env.HMI_TOKEN_TENANT
      env.HMI_GRANT_TYPE = env.HMI_GRANT_TYPE
      env.HMI_TRG_API_URL = env.HMI_SIT_API_URL
    }

    currentBuild.description = "Running tests in environment: ${params.ENVIRONMENT}<br>Suite: ${params.TEST_SUITE}"

    // --- PR & BVT/Regression logic ---
    if (isPrBuild) {
      // If TAGS_TO_RUN is specified, run only those tags and skip normal PR logic
      if (params.TAGS_TO_RUN && !params.TAGS_TO_RUN.isEmpty()) {
        stage("PR: ${params.TAGS_TO_RUN} E2E Tests ${params.browser}") {
          try {
            currentBuild.displayName = "PR: ${params.TAGS_TO_RUN} E2E Tests"
            yarnBuilder.yarn(buildPlaywrightCommand(params.TAGS_TO_RUN))
          } catch (Error) {
            unstable(message: "${STAGE_NAME} is unstable: " + Error.toString())
          } finally {
            publishHTML([
              allowMissing: true,
              alwaysLinkToLastBuild: true,
              keepAll: true,
              reportDir: "playwright-report",
              reportFiles: 'index.html',
              reportName: "PR: ${params.TAGS_TO_RUN} E2E Tests ${params.browser}"
            ])
          }
        }
      } else {
        // Check if @pr-build should be skipped
        def prBuildConfig = testConfigs.find { it.grep == '@pr-build' }
        if (prBuildConfig && prBuildConfig.skip == 'true') {
          echo "Skipping stage: PR: @pr-build Tagged Tests because skip is set to true"
        } else {
          stage("PR: @pr-build Tagged Tests") {
            try {
              currentBuild.displayName = "PR: @pr-build Tagged Tests"
              yarnBuilder.yarn("playwright test --grep @pr-build --project=${params.browser}")
            } catch (Error) {
              unstable(message: "${STAGE_NAME} is unstable: " + Error.toString())
            } finally {
              publishHTML([
                allowMissing: true,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: "playwright-report",
                reportFiles: 'index.html',
                reportName: "PR: @pr-build Tagged Tests"
              ])
            }
          }
        }

        // Run changed bvt spec.ts files
        bvtSpecFilesChanged.each { file ->
          stage("PR: BVT Changed File - ${file}") {
            try {
              currentBuild.displayName = "PR: BVT Changed File - ${file}"
              yarnBuilder.yarn("playwright test ${file} --project=${params.browser}")
            } catch (Error) {
              unstable(message: "${STAGE_NAME} is unstable: " + Error.toString())
            } finally {
              publishHTML([
                allowMissing: true,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: "playwright-report",
                reportFiles: 'index.html',
                reportName: "PR: BVT Changed File - ${file}"
              ])
            }
          }
        }

        // Run changed regression spec.ts files
        regressionSpecFilesChanged.each { file ->
          stage("PR: Regression Changed File - ${file}") {
            try {
              currentBuild.displayName = "PR: Regression Changed File - ${file}"
              yarnBuilder.yarn("playwright test ${file} --project=${params.browser}")
            } catch (Error) {
              unstable(message: "${STAGE_NAME} is unstable: " + Error.toString())
            } finally {
              publishHTML([
                allowMissing: true,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: "playwright-report",
                reportFiles: 'index.html',
                reportName: "PR: Regression Changed File - ${file}"
              ])
            }
          }
        }
      }
    } else if (params.TAGS_TO_RUN && !params.TAGS_TO_RUN.isEmpty()) {
      stage("${params.TAGS_TO_RUN} E2E Tests ${params.browser}") {
        try {
          currentBuild.displayName = "${params.TAGS_TO_RUN} E2E Tests"
          yarnBuilder.yarn(buildPlaywrightCommand(params.TAGS_TO_RUN))
        } catch (Error) {
          unstable(message: "${STAGE_NAME} is unstable: " + Error.toString())
        } finally {
          publishHTML([
            allowMissing: true,
            alwaysLinkToLastBuild: true,
            keepAll: true,
            reportDir: "playwright-report",
            reportFiles: 'index.html',
            reportName: "${params.TAGS_TO_RUN} E2E Tests ${params.browser}"
          ])
        }
      }
    } else if (regressionBlockChanged) {
      runRegressionStages(regressionStages)
      runBvtStages(bvtStages)
    } else {
      if (params.TEST_SUITE == 'bvt') {
        runBvtStages(bvtStages)
      }
      if (params.TEST_SUITE == 'regression') {
        runRegressionStages(regressionStages)
      }
      if (params.TEST_SUITE == 'bvt_and_regression') {
        runBvtStages(bvtStages)
        runRegressionStages(regressionStages)
      }
    }
  }
}
